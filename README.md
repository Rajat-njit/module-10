---

# ðŸ§  Module 10 â€“ Secure User Model with FastAPI, SQLAlchemy, Pydantic & CI/CD

---

## ðŸ›¡ï¸ Build, Test, and Deploy a Secure FastAPI Application

[![CI/CD Pipeline â€“ Secure User Model](https://github.com/Rajat-njit/module-10/actions/workflows/ci.yml/badge.svg)](https://github.com/Rajat-njit/module-10/actions/workflows/ci.yml)
---

## ðŸ“– Overview

This project implements a **secure user management system** using **FastAPI**, **SQLAlchemy**, and **Pydantic**, backed by a **PostgreSQL** database and deployed through a **CI/CD pipeline** to **Docker Hub**.

The system ensures **data integrity**, **password security**, and **continuous reliability** through automated testing and deployment.

### ðŸ” Key Objectives:

1. **Create a Secure User Model**

   * Hash passwords using bcrypt.
   * Enforce unique constraints for `username` and `email`.
   * Automatically generate `created_at` timestamps.
2. **Validate Inputs with Pydantic**

   * Enforce strict validation (email format, password length).
   * Separate user creation vs. response models (`UserCreate`, `UserRead`).
3. **Automate Testing & Deployment**

   * Unit & integration tests run on every push to GitHub.
   * Docker image automatically built, scanned (Trivy), and pushed to Docker Hub.

---

## ðŸ“ Project Structure

```bash
module-10/
â”‚
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ config.py
â”‚   â”œâ”€â”€ database.py
â”‚   â”œâ”€â”€ database_init.py
â”‚   â”œâ”€â”€ dependencies.py
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ user.py
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â””â”€â”€ user.py
â”‚   â”œâ”€â”€ operations/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ user.py
â”‚   â””â”€â”€ routes/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ user_routes.py
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”‚   â”œâ”€â”€ test_models.py
â”‚   â”‚   â”œâ”€â”€ test_schemas.py
â”‚   â”‚   â”œâ”€â”€ test_dependencies.py
â”‚   â””â”€â”€ integration/
â”‚       â”œâ”€â”€ test_user_ops.py
â”‚       â”œâ”€â”€ test_database.py
â”‚       â””â”€â”€ test_endpoints.py
â”‚
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ dockerfile
â”œâ”€â”€ pytest.ini
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .github/workflows/ci.yml
â””â”€â”€ README.md
```

---

## ðŸ§° Requirements

Below is the `requirements.txt` used in this project:

```txt
fastapi==0.115.0
uvicorn==0.30.0
sqlalchemy==2.0.34
psycopg[binary]==3.2.12

passlib[bcrypt]==1.7.4
pydantic==2.9.2
pytest==8.3.3
pytest-cov==5.0.0
Faker==30.3.0
python-dotenv==1.0.1
pydantic-settings==2.5.2
httpx==0.27.2
email-validator==2.2.0
```

Create a `.env` file (for local environment):

```bash
DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/test_db
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=test_db
```

---

## ðŸš€ Step-by-Step Execution

### 1ï¸âƒ£ Create and Activate Virtual Environment

```bash
python3 -m venv venv
source venv/bin/activate
```

### 2ï¸âƒ£ Install Dependencies

```bash
pip install --upgrade pip
pip install -r requirements.txt
```

### 3ï¸âƒ£ Run the Application Locally

```bash
uvicorn app.main:app --reload
```

Visit the interactive docs:

> **[http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)**

Expected endpoints:

* `POST /users/` â†’ Create a new user
* `GET /users/{id}` â†’ Retrieve a user by ID
* `GET /docs` â†’ Open Swagger UI

---

## ðŸ§± SQLAlchemy User Model

Located at `app/models/user.py`:

```python
from sqlalchemy import Column, Integer, String, DateTime, func
from passlib.context import CryptContext
from app.database import Base

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, nullable=False)
    email = Column(String, unique=True, nullable=False)
    password_hash = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    @staticmethod
    def hash_password(password: str) -> str:
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)
```

### âœ… Highlights

* Passwords **never stored in plain text**.
* Unique constraints for both `email` and `username`.
* `created_at` timestamp auto-generated by the database.

---

## ðŸ§© Pydantic Schemas

Located at `app/schemas/base.py`:

```python
from pydantic import BaseModel, EmailStr, Field

class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, max_length=72)

class UserRead(UserBase):
    id: int
    class Config:
        from_attributes = True
```

### âœ… What They Do:

* **UserCreate:** Validates incoming user data (email format, password length).
* **UserRead:** Controls what is exposed in API responses (no password field).

---

## ðŸ” Hashing & Verification

Example from `app/models/user.py`:

```python
hashed = User.hash_password("MySecurePassword123")
assert User.verify_password("MySecurePassword123", hashed)
```

**Why hashing matters:**

* Even if attackers access your DB, raw passwords remain unrecoverable.
* Salting ensures that even identical passwords produce different hashes.

---

## ðŸ§ª Testing ( Unit + Integration )

### Unit Tests â€“ `tests/unit`

#### ðŸ”¸ Password Hashing

```python
def test_password_hash_and_verify():
    password = "Secure123"
    hashed = User.hash_password(password)
    assert hashed != password
    assert User.verify_password(password, hashed)
```

#### ðŸ”¸ Validation with Pydantic

```python
from pydantic import ValidationError
from app.schemas.base import UserCreate

def test_invalid_email_schema():
    with pytest.raises(ValidationError):
        UserCreate(username="abc", email="notanemail", password="StrongPass1")
```

#### ðŸ”¸ User Length & Empty Fields

```python
import pytest
def test_username_too_short():
    with pytest.raises(ValidationError):
        UserCreate(username="a", email="a@b.com", password="Valid1234")
```

### Using **Faker** for Synthetic Users

The `faker` library creates realistic dummy users for testing bulk operations:

```python
from faker import Faker
fake = Faker()

def test_bulk_user_creation(db_session):
    for _ in range(5):
        u = create_user(
            db_session,
            username=fake.user_name(),
            email=fake.email(),
            password="StrongPass1"
        )
        assert "@" in u.email
```

Faker ensures data variety without hard-coded values.

---

### Integration Tests â€“ `tests/integration`

Use a real PostgreSQL database (simulated in CI/CD or via Docker Compose).

```python
def test_create_and_retrieve_user(db_session):
    u = create_user(db_session, "raj", "raj@example.com", "Secure123")
    r = get_user_by_username(db_session, "raj")
    assert r.email == "raj@example.com"

def test_user_not_found_returns_none(db_session):
    assert get_user_by_username(db_session, "ghost_user") is None
```

Also test **unique constraint** errors:

```python
import pytest
from sqlalchemy.exc import IntegrityError

def test_duplicate_username(db_session):
    create_user(db_session, "sam", "sam@mail.com", "Pass1234")
    with pytest.raises(IntegrityError):
        create_user(db_session, "sam", "sam2@mail.com", "Pass1234")
```
---

## âš™ï¸ Configure CI/CD Pipeline

### ðŸ”§ `.github/workflows/ci.yml`

```yaml
name: CI/CD Pipeline â€“ Secure User Model

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
    env:
      DATABASE_URL: postgresql+psycopg2://postgres:postgres@localhost:5432/test_db
      PYTHONPATH: .
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - run: |
          pip install --upgrade pip
          pip install -r requirements.txt
      - run: |
          pytest --cov=app --cov-report=xml --cov-report=term-missing
          coverage xml
      - run: |
          echo "### âœ… Pytest Coverage Report" >> $GITHUB_STEP_SUMMARY
          coverage report >> $GITHUB_STEP_SUMMARY

  build:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ secrets.DOCKER_USERNAME }}/module-10:latest
```

### âœ… Workflow Summary

* **Stage 1:** Runs tests + coverage with a PostgreSQL service.
* **Stage 2:** Builds and pushes image to Docker Hub.
* **Stage 3:** Generates Trivy security report.

---

## ðŸ³ Docker Commands for Local Use

### Build and Run

```bash
docker compose up --build
```

### Run in Detached Mode

```bash
docker compose up -d
```

### Stop and Remove

```bash
docker compose down -v
```

### Pull from Docker Hub

```bash
docker pull rajatpednekar/module-10:latest
```

---

## ðŸ§  Special Mentions â€“ Security & Automation

### ðŸ”’ Secure User Model

* SQLAlchemy model with unique constraints & hashed passwords
* Automatic timestamping of user creation
* Pydantic schemas restrict exposure of sensitive fields

### âš™ï¸ Testing & CI/CD

* Unit and integration tests achieve > 90% coverage
* GitHub Actions pipeline runs tests, builds Docker image, scans with Trivy, and pushes to Docker Hub

---

## ðŸ§ª More User Validation Tests

### Invalid Email Format

```python
def test_reject_invalid_email():
    payload = {"username": "raj", "email": "invalid-email", "password": "Secure123"}
    response = client.post("/users/", json=payload)
    assert response.status_code == 422
```

### Duplicate Email Detection

```python
def test_duplicate_email_not_allowed(db_session):
    create_user(db_session, "alpha", "alpha@mail.com", "Strong123")
    with pytest.raises(Exception):
        create_user(db_session, "beta", "alpha@mail.com", "Strong123")
```

### Password Too Short

```python
def test_short_password_fails_validation():
    with pytest.raises(ValidationError):
        UserCreate(username="raj", email="raj@mail.com", password="123")
```

These cases ensure validation covers realistic user input scenarios and prevent data integrity issues.

---

## ðŸ§ª How to Interpret Test Results

After running pytest:

```
=================== 14 passed in 0.82s ===================
---------- coverage: platform darwin, python 3.11 ----------
Name                         Stmts   Miss  Cover
------------------------------------------------
app/models/user.py              40      2    95%
app/schemas/base.py             19      0   100%
TOTAL                          135      6    92%
```

âœ… All green â†’ pipeline passes â†’ Docker Hub deploy triggered.

---

## ðŸ§ª How to Run Tests Locally (in Depth)

### ðŸ§© Option 1 â€“ Local PostgreSQL Container

1ï¸âƒ£ Start Postgres:

```bash
docker run --name postgres-test \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=test_db \
  -p 5432:5432 \
  -d postgres:16
```

2ï¸âƒ£ Activate env + run tests:

```bash
source venv/bin/activate
pytest -v -s --cov=app --cov-report=term-missing
```

3ï¸âƒ£ Stop when done:

```bash
docker stop postgres-test
docker rm postgres-test
```

---

### ðŸ§© Option 2 â€“ Run Tests via Docker Compose (Recommended)

This approach spins up both Postgres and FastAPI in one command and lets you test exactly as the CI/CD pipeline does.

```bash
docker compose up --build --detach
docker exec -it fastapi_app pytest -v --cov=app
```

* `fastapi_app` = container name of your API service
* The tests run inside the Docker environment with the same settings as production.

Then generate coverage:

```bash
docker exec -it fastapi_app coverage report
```

To shut down:

```bash
docker compose down -v
```

âœ… **Benefit:** Isolated environment ensures consistent results between local and GitHub Actions.

---

## ðŸ‹ Docker Hub Repository

**Repository Link:**
ðŸ”— [https://hub.docker.com/r/rajatpednekar/module-10](https://hub.docker.com/r/rajatpednekar/module-10)

**Image Name:**
`rajatpednekar/module-10:latest`

### ðŸ§¾ Example Pull Command

```bash
docker pull rajatpednekar/module-10:latest
docker run -d -p 8000:8000 rajatpednekar/module-10:latest
```

### âš™ï¸ Expected Output

```bash
INFO:     Started server process [1]
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000
```

Then open:

> **[http://localhost:8000/docs](http://localhost:8000/docs)**

---


## ðŸŽ“ Conclusion

This project demonstrates a **complete backend engineering workflow** â€” from secure model design and validation to automated testing and CI/CD deployment.

It reflects a professional-grade architecture that can be easily extended into production environments with minimal changes. Through this module, I not only implemented key components of a secure system but also understood how testing, automation, and deployment form the backbone of sustainable software development.

---

