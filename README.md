

---

# ğŸ§  Module 10 â€“ Secure User Model with FastAPI, SQLAlchemy, Pydantic & CI/CD

---

## ğŸ›¡ï¸ Build, Test, and Deploy a Secure FastAPI Application

[![CI/CD Pipeline â€“ Secure User Model](https://github.com/Rajat-njit/module-10/actions/workflows/ci.yml/badge.svg)](https://github.com/Rajat-njit/module-10/actions/workflows/ci.yml)
---

## ğŸ“– Overview

This project implements a **secure user management system** using **FastAPI**, **SQLAlchemy**, and **Pydantic**, backed by a **PostgreSQL** database and deployed through a **CI/CD pipeline** to **Docker Hub**.

The system ensures **data integrity**, **password security**, and **continuous reliability** through automated testing and deployment.

### ğŸ” Key Objectives:

1. **Create a Secure User Model**

   * Hash passwords using bcrypt.
   * Enforce unique constraints for `username` and `email`.
   * Automatically generate `created_at` timestamps.
2. **Validate Inputs with Pydantic**

   * Enforce strict validation (email format, password length).
   * Separate user creation vs. response models (`UserCreate`, `UserRead`).
3. **Automate Testing & Deployment**

   * Unit & integration tests run on every push to GitHub.
   * Docker image automatically built, scanned (Trivy), and pushed to Docker Hub.

---

## ğŸ“ Project Structure

```bash
module-10/
â”‚
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ config.py
â”‚   â”œâ”€â”€ database.py
â”‚   â”œâ”€â”€ database_init.py
â”‚   â”œâ”€â”€ dependencies.py
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ user.py
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â””â”€â”€ user.py
â”‚   â”œâ”€â”€ operations/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ user.py
â”‚   â””â”€â”€ routes/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ user_routes.py
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”‚   â”œâ”€â”€ test_models.py
â”‚   â”‚   â”œâ”€â”€ test_schemas.py
â”‚   â”‚   â”œâ”€â”€ test_dependencies.py
â”‚   â””â”€â”€ integration/
â”‚       â”œâ”€â”€ test_user_ops.py
â”‚       â”œâ”€â”€ test_database.py
â”‚       â””â”€â”€ test_endpoints.py
â”‚
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ dockerfile
â”œâ”€â”€ pytest.ini
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .github/workflows/ci.yml
â””â”€â”€ README.md
```

---

## ğŸ§° Requirements

Below is the `requirements.txt` used in this project:

```txt
fastapi==0.115.0
uvicorn==0.30.0
sqlalchemy==2.0.34
psycopg[binary]==3.2.12

passlib[bcrypt]==1.7.4
pydantic==2.9.2
pytest==8.3.3
pytest-cov==5.0.0
Faker==30.3.0
python-dotenv==1.0.1
pydantic-settings==2.5.2
httpx==0.27.2
email-validator==2.2.0
```

Create a `.env` file (for local environment):

```bash
DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/test_db
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=test_db
```

---

## ğŸš€ Step-by-Step Execution

### 1ï¸âƒ£ Create and Activate Virtual Environment

```bash
python3 -m venv venv
source venv/bin/activate
```

### 2ï¸âƒ£ Install Dependencies

```bash
pip install --upgrade pip
pip install -r requirements.txt
```

### 3ï¸âƒ£ Run the Application Locally

```bash
uvicorn app.main:app --reload
```

Visit the interactive docs:

> **[http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)**

Expected endpoints:

* `POST /users/` â†’ Create a new user
* `GET /users/{id}` â†’ Retrieve a user by ID
* `GET /docs` â†’ Open Swagger UI

---

## ğŸ§± SQLAlchemy User Model

Located at `app/models/user.py`:

```python
from sqlalchemy import Column, Integer, String, DateTime, func
from passlib.context import CryptContext
from app.database import Base

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, nullable=False)
    email = Column(String, unique=True, nullable=False)
    password_hash = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    @staticmethod
    def hash_password(password: str) -> str:
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)
```

### âœ… Highlights

* Passwords **never stored in plain text**.
* Unique constraints for both `email` and `username`.
* `created_at` timestamp auto-generated by the database.

---

## ğŸ§© Pydantic Schemas

Located at `app/schemas/base.py`:

```python
from pydantic import BaseModel, EmailStr, Field

class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, max_length=72)

class UserRead(UserBase):
    id: int
    class Config:
        from_attributes = True
```

### âœ… What They Do:

* **UserCreate:** Validates incoming user data (email format, password length).
* **UserRead:** Controls what is exposed in API responses (no password field).

---

## ğŸ” Hashing & Verification

Example from `app/models/user.py`:

```python
hashed = User.hash_password("MySecurePassword123")
assert User.verify_password("MySecurePassword123", hashed)
```

**Why hashing matters:**

* Even if attackers access your DB, raw passwords remain unrecoverable.
* Salting ensures that even identical passwords produce different hashes.

---

## ğŸ§ª Unit and Integration Testing

Testing ensures both **code reliability** and **database integrity**.

### âœ… Unit Tests (`tests/unit/`)

Example: `test_models.py`

```python
def test_password_hash_and_verify():
    password = "Secure123"
    hashed = User.hash_password(password)
    assert User.verify_password(password, hashed)
```

### âœ… Integration Tests (`tests/integration/`)

These use a real **PostgreSQL** container for database-backed validation.

Example: `test_user_ops.py`

```python
def test_create_and_retrieve_user(db_session):
    user = create_user(db_session, username="raj", email="raj@example.com", password="Secure123")
    retrieved = get_user_by_username(db_session, "raj")
    assert retrieved.email == "raj@example.com"
```

---

## âš™ï¸ Configure CI/CD Pipeline

### ğŸ”§ `.github/workflows/ci.yml`

```yaml
name: CI/CD Pipeline â€“ Secure User Model

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
    env:
      DATABASE_URL: postgresql+psycopg2://postgres:postgres@localhost:5432/test_db
      PYTHONPATH: .
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - run: |
          pip install --upgrade pip
          pip install -r requirements.txt
      - run: |
          pytest --cov=app --cov-report=xml --cov-report=term-missing
          coverage xml
      - run: |
          echo "### âœ… Pytest Coverage Report" >> $GITHUB_STEP_SUMMARY
          coverage report >> $GITHUB_STEP_SUMMARY

  build:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ secrets.DOCKER_USERNAME }}/module-10:latest
```

### âœ… Workflow Summary

* **Stage 1:** Runs tests + coverage with a PostgreSQL service.
* **Stage 2:** Builds and pushes image to Docker Hub.
* **Stage 3:** Generates Trivy security report.

---

## ğŸ³ Docker Commands for Local Use

### Build and Run

```bash
docker compose up --build
```

### Run in Detached Mode

```bash
docker compose up -d
```

### Stop and Remove

```bash
docker compose down -v
```

### Pull from Docker Hub

```bash
docker pull rajatpednekar/module-10:latest
```

---

## ğŸ§  Special Mention â€” Key Learnings

### ğŸ”¹ Secure User Model

* SQLAlchemy model enforces uniqueness and strong password hashing.
* No sensitive data (like raw passwords) is ever logged or stored.

### ğŸ”¹ Pydantic Validation

* Ensures correct email format and password constraints.
* Clean separation between input (`UserCreate`) and output (`UserRead`).

### ğŸ”¹ Testing & CI/CD

* Local tests mirror GitHub Actions workflow.
* Every commit triggers a pipeline â†’ test â†’ scan â†’ build â†’ deploy.

---

## ğŸ§ª How to Run Tests Locally

To replicate CI/CD tests locally:

1. **Start PostgreSQL container**

   ```bash
   docker run --name postgres-test \
     -e POSTGRES_USER=postgres \
     -e POSTGRES_PASSWORD=postgres \
     -e POSTGRES_DB=test_db \
     -p 5432:5432 \
     -d postgres:16
   ```

2. **Activate environment**

   ```bash
   source venv/bin/activate
   ```

3. **Run all tests**

   ```bash
   pytest -v -s --cov=app --cov-report=term-missing
   ```

4. **Run individual files**

   ```bash
   pytest tests/unit/test_models.py -v
   pytest tests/integration/test_user_ops.py -v
   ```

5. **Check coverage**

   ```bash
   coverage report
   ```

Expected output:

```
=================== 14 passed in 0.83s ===================
---------- coverage: 92% ----------
```

---

## ğŸ‹ Docker Hub Repository

**Repository Link:**
ğŸ”— [https://hub.docker.com/r/rajatpednekar/module-10](https://hub.docker.com/r/rajatpednekar/module-10)

**Image Name:**
`rajatpednekar/module-10:latest`

### ğŸ§¾ Example Pull Command

```bash
docker pull rajatpednekar/module-10:latest
docker run -d -p 8000:8000 rajatpednekar/module-10:latest
```

### âš™ï¸ Expected Output

```bash
INFO:     Started server process [1]
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000
```

Then open:

> **[http://localhost:8000/docs](http://localhost:8000/docs)**

---


## ğŸ“ Conclusion

This project demonstrates a **complete backend engineering workflow** â€” from secure model design and validation to automated testing and CI/CD deployment.

It reflects a professional-grade architecture that can be easily extended into production environments with minimal changes. Through this module, I not only implemented key components of a secure system but also understood how testing, automation, and deployment form the backbone of sustainable software development.

---

Would you like me to format this version with **GitHub-style collapsible sections** (`<details>` tags) and icons (ğŸš€ ğŸ§© ğŸ”) to make your submission visually outstanding on GitHub?
